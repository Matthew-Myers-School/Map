#include <iostream>#include <time.h>#include <string>#include <sstream>#include <vector>#include <climits>#ifndef MAP_HPP#define MAP_HPPnamespace cs540{template<typename Key_T, typename value_T>struct SkipNode {    Key_T key;    value_T value;            std::vector<SkipNode<Key_T, value_T>*> forward;    std::vector<SkipNode<Key_T, value_T>*> previous;    SkipNode (Key_T k, const value_T& v, int level)    {        key = k;        value = v;        for (int i = 0; i < level; ++i)        {            forward.push_back(NULL);            previous.push_back(NULL);        }    } ;};                //==============================================================================template<typename Key_T, typename value_T>class Map {public:    class iterator;    class Constiterator;    class ReverseIterator;    class iterator {    public:        SkipNode<Key_T, value_T> *current;        void print()        {            std::cout <<"K: " << current->key << " V: " << current->value << std::endl;        }        iterator& operator++(){            current = current->forward[0];            return *this;        }        iterator operator++(int){            current = current->forward[0];            return *this;        }        iterator& operator--() {         current = current->previous[0];         return *this;        }            iterator operator--(int) {            current = current->previous[0];            return *this;        }        bool operator==(const iterator& compIt)        {            if (this->current->key == compIt.current->key && this->current->value == compIt.current->value)                return true;            return false;        }        bool operator!=(const iterator& compIt)        {            if (this->current->key != compIt.current->key || this->current->value != compIt.current->value)                return true;            return false;        }        bool operator==(const Constiterator& compIt)        {            if (this->current->key == compIt.current->key && this->current->value == compIt.current->value)                return true;            return false;        }        bool operator!=(const Constiterator& compIt)        {            if (this->current->key != compIt.current->key || this->current->value != compIt.current->value)                return true;            return false;        }    };//end of iterator            class Constiterator {    public:        SkipNode<Key_T, value_T> *current;        void print()        {            std::cout <<"K: " << current->key << " V: " << current->value << std::endl;        }        Constiterator& operator++(){            current = current->forward[0];            return *this;        }        Constiterator operator++(int){            current = current->forward[0];            return *this;        }        Constiterator& operator--() {            current = current->previous[0];            return *this;        }                        Constiterator operator--(int) {            current = current->previous[0];            return *this;        }                bool operator==(const iterator& compIt)        {            if (this->current->key == compIt.current->key && this->current->value == compIt.current->value)                return true;            return false;        }        bool operator!=(const iterator& compIt)        {            if (this->current->key != compIt.current->key || this->current->value != compIt.current->value)                return true;            return false;        }        bool operator==(const Constiterator& compIt)        {            if (this->current->key == compIt.current->key && this->current->value == compIt.current->value)                return true;            return false;        }        bool operator!=(const Constiterator& compIt)        {            if (this->current->key != compIt.current->key || this->current->value != compIt.current->value)                return true;            return false;        }    };//end of const iterator    public:    size_t sizet;    int maxLevel;    SkipNode<Key_T, value_T> *head;public:    Map()    {        head = new SkipNode<Key_T, value_T>(INT_MIN, "h", 32);        sizet = 0;    } ;    ~Map ()    {        delete head;    };    size_t size()    {        return sizet;    }    iterator find(Key_T searchKey)    {        SkipNode<Key_T, value_T>* x = NULL;        bool repeat = true;        x = head;        for (int i = 31; i > -1; i--)        {            repeat = true;            if (x->forward[i] != NULL)            {                while (repeat)                {                    if (x->forward[i]->key < searchKey)                    {                        x = x->forward[i];                    }                    else                        repeat = false;                    //x for is null                                        if (x->forward[i] == NULL)                    {                        repeat = false;                    }                }                if (x->forward[i] != NULL)                {                    if (x->forward[i]->key == searchKey)                    {                        x = x->forward[i];                        iterator *tmp = new iterator();                        tmp->current = x;                        return *tmp;                    }                }            }        }        iterator *tmp = new iterator();        return *tmp;    }    bool empty()    {        if ((int)sizet==0)            return true;        return false;    }    iterator begin()    {        iterator *it = new iterator();        it->current = head->forward[0];        return *it;    }    iterator end()    {        iterator *et = new iterator();        et->current = head->forward[0];        for (int i = 1; i < (int)sizet ; i++)        {            et->current = et->current->forward[0];        }        return *et;    }    void print () {        SkipNode<Key_T, value_T> *tester;        tester = head;        int Tarray[13];        for (int i = 0; i < 13; i++)        {            Tarray[i] = 0;        }        for (int i = 31; i > -1; i--)        {            tester = head;            std::cout << std::endl;            if (tester->forward[i] != NULL)            {                for (int j = 0; j < (int)sizet; j++)                {                    if (tester->forward[i] != NULL)                    {                        tester = tester->forward[i];                        Tarray[tester->key] = tester->key;                    }                    //Tarray[tester->key] = tester->key;                }            }            for (int k = 1; k < 13; k++)            {                std::cout << Tarray[k] << "\t";            }            for (int l = 0; l < (int)sizet; l++)            {                Tarray[l] = 0;            }        }        std::cout << std::endl;    };    void erase (Key_T searchKey)    {        bool repeat = false;        SkipNode<Key_T, value_T>* x = NULL;        SkipNode<Key_T, value_T>* y = NULL;        std::vector<SkipNode<Key_T, value_T>*> needsUpdating;        x = head;        for (int i = 31; i > -1; i--)        {            repeat = true;            if (x->forward[i] != NULL)            {                while (repeat)                {                    if (x->forward[i]->key != searchKey)                    {                        x = x->forward[i];                    }                    else                    {                        needsUpdating.insert(needsUpdating.begin(), x);                        repeat = false;                    }                    if (x->forward[i] == NULL)                    {                        repeat = false;                    }                }            }        }                            y = needsUpdating[0]->forward[0];        for (int i = 0; i < (int)needsUpdating.size(); i++)        {            if (needsUpdating[i]->forward[i] != NULL)            {                if (needsUpdating[i]->forward[i]->forward[i] != NULL)                {                    needsUpdating[i]->forward[i]->forward[i]->previous[i] = needsUpdating[i];                    needsUpdating[i]->forward[i] = needsUpdating[i]->forward[i]->forward[i];                }                else                {                    needsUpdating[i]->forward[i] = NULL;                }            }        }        sizet--;        delete y;    }    void insert (std::pair< Key_T,value_T> p)    {        //std::cout << "P: " << p.first;        bool repeat = true;        Key_T searchKey = p.first;        value_T newValue = p.second;        SkipNode<Key_T, value_T>* x = NULL;        std::vector<SkipNode<Key_T, value_T>*> needsUpdating;        x = head;        for (int i = 31; i > -1; i--)        {            repeat = true;            if (x->forward[i] != NULL)            {                while (repeat)                {                    if (x->forward[i]->key < searchKey)                    {                        x = x->forward[i];                    }                    else                        repeat = false;                    //x for is null                                        if (x->forward[i] == NULL)                    {                        repeat = false;                    }                }                if (x->forward[i] != NULL)                {                    if (x->forward[i]->key == searchKey)                    {                        x->forward[i]->value = newValue;                        return;                    }                }            }        }        x = NULL;        x = head;        int insertLevel = rand() % 32;        //std::cout << " L: " << insertLevel;        for (int i = 31; i > -1; i--)        {            if (x->forward[i] != NULL)            {                while (x->forward[i] != NULL && x->forward[i]->key < searchKey)                {                        x = x->forward[i];                }                if (i < insertLevel)                {                    needsUpdating.insert(needsUpdating.begin(), x);                }            }            else if (x->forward[i] == NULL && i < insertLevel)            {                needsUpdating.insert(needsUpdating.begin(), x);            }        }        x = makeNode(searchKey, newValue, 32);        //std::cout << "NUS: " << needsUpdating.size() << std::endl;        for (int i = 0; i < insertLevel; i++)        {            x->forward[i] = needsUpdating[i]->forward[i];            needsUpdating[i]->forward[i] = x;            x->previous[i] = needsUpdating[i];            if (x->forward[i]!=NULL)            {                x->forward[i]->previous[i] = x;            }        }        sizet++;    };    private:    SkipNode<Key_T, value_T>* makeNode (int key, std::string val, int level)    {        return new SkipNode<Key_T, value_T>(key, val, level);    };};};#endif